<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.76.5" />

  <title> 【MySQL】事务默认隔离级别 |  looper梦呓</title>
  <meta name="description" content="A simple and concise hugo theme.">
  <link rel="stylesheet" href="https://1004032560.github.io/css/index.css">
  <link rel="stylesheet" href="https://1004032560.github.io/css/classes.css">
  <link rel="canonical" href="https://1004032560.github.io/posts/mysqlmysql%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">
  <link rel="alternate" type="application/rss+xml" href="" title="looper梦呓">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
</head>

<body>
  <header class="menus">
  

  <nav >
    
    <a href="/"> looper梦呓</a>
    
    <a href="/tags"> Tags</a>
    
    <a href="/about/about"> About</a>
    
  </nav>

  <nav class="fontawesome">
    
    <a href="https://github.com/1004032560" target="_blank">
        <i title="GitHub" class="fab fa-github"></i>
    </a>
    
    
    <a href="https://mp.weixin.qq.com/s/HpWP32efkOUumg7fUGZV1g" target="_blank">
        <i title="微信公众号" class="fab fa-weixin"></i>
    </a>
    
    
    <a href="https://1004032560.github.io/index.xml" target="_blank">
        <i title="RSS" class="fas fa-rss"></i>
    </a>
    
  </nav>
  
  
  <div class="hidden description">A simple and concise hugo theme.</div>
  
</header>

<article id="article">
  <header>
  

    <h1 style="text-align: center;" >【MySQL】事务默认隔离级别</h1>
    <div class="post-meta">
    
      <time datetime="2021-05-11T06:09:38&#43;08:00">May 11, 2021</time> &nbsp; 
    

    looper &nbsp;

    
    
    

    
      <i class="far fa-clock"></i>
      
      
      

      
        10 min
      
      18 s
      &nbsp;
    
    </div>
  </header>

  <h2 id="mysql事务默认隔离级别">MySQL事务默认隔离级别</h2>
<p>MySQL 数据库事务的默认隔离级别为 Repeatable Read 简称 RR。</p>
<p>Oracle 数据库事务的默认隔离级别为 Read Committed 简称 RC。</p>
<p>MySQL 在 5.0 这个版本以前，binlog 只支持 <code>STATEMENT</code> 这种格式！而这种格式在读已提交 Read Commited 这个隔离级别下主从复制是有 BUG 的，因此 MySQL 将可重复读 Repeatable Read 作为默认的隔离级别！</p>
<p>由于历史原因</p>
<p>主从复制，是基于binlog复制的！</p>
<p>binlog 三种格式，分别是</p>
<ul>
<li>statement：记录的是修改 SQL 语句（基于语句的主从复制）</li>
<li>row：记录的是每行实际数据的变更（基于行锁的主从复制）</li>
<li>mixed：statement 和 row 模式的混合</li>
</ul>
<p>这样，你就出现了主从不一致性的问题！原因其实很简单，就是在主（master）上执行的顺序为先删后插！而此时 binlog 为 STATEMENT 格式，它记录的顺序为先插后删！从（slave）同步的是 binlog，因此从机执行的顺序和主机不一致！就会出现主从不一致！</p>
<p>解决方案有两种！</p>
<ol>
<li>
<p>隔离级别设为「可重复读 Repeatable Read」，在该隔离级别下引入间隙锁。当<code>Session 1</code>执行delete语句时，会锁住间隙。那么，<code>Ssession 2</code>执行插入语句就会阻塞住！</p>
</li>
<li>
<p>将binglog的格式修改为row格式，此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！奈何这个格式在mysql5.1版本开始才引入。因此由于历史原因，mysql将默认的隔离级别设为<strong>可重复读(Repeatable Read)</strong>，保证主从复制不出问题！</p>
</li>
</ol>
<p>那么，当我们了解完mysql选<strong>可重复读(Repeatable Read)<strong>作为默认隔离级别的原因后，接下来我们将其和</strong>读已提交(Read Commited)<strong>进行对比，来说明为什么在互联网项目为什么将隔离级别设为</strong>读已提交(Read Commited)</strong>！</p>
<h3 id="对比">对比</h3>
<p>ok，我们先明白一点！项目中是不用**读未提交(Read UnCommitted)<strong>和</strong>串行化(Serializable)**两个隔离级别，原因有二</p>
<ul>
<li>采用<strong>读未提交(Read UnCommitted)</strong>,一个事务读到另一个事务未提交读数据，这个不用多说吧，从逻辑上都说不过去！</li>
<li>采用<strong>串行化(Serializable)</strong>，每个次读操作都会加锁，快照读失效，一般是使用mysql自带分布式事务功能时才使用该隔离级别！(笔者从未用过mysql自带的这个功能，因为这是XA事务，是强一致性事务，性能不佳！互联网的分布式方案，多采用最终一致性的事务解决方案！)</li>
</ul>
<p>也就是说，我们该纠结都只有一个问题，究竟隔离级别是用读已经提交呢还是可重复读？
接下来对这两种级别进行对比，<strong>讲讲我们为什么选读已提交(Read Commited)作为事务隔离级别！</strong>
假设表结构如下</p>
<pre><code> CREATE TABLE `test` (
`id` int(11) NOT NULL,
`color` varchar(20) NOT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB
</code></pre><p>数据如下</p>
<pre><code>+----+-------+
| id | color |
+----+-------+
|  1 |  red  |
|  2 | white |
|  5 |  red  |
|  7 | white |
+----+-------+
</code></pre><p>为了便于描述，下面将</p>
<ul>
<li><strong>可重复读(Repeatable Read)</strong>，简称为RR；</li>
<li><strong>读已提交(Read Commited)</strong>，简称为RC；</li>
</ul>
<p>*<strong>缘由一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！*</strong>
此时执行语句</p>
<pre><code>select * from test where id &lt;3 for update;
</code></pre><p>在RR隔离级别下，存在间隙锁，可以锁住(2,5)这个间隙，防止其他事务插入数据！
而在RC隔离级别下，不存在间隙锁，其他事务是可以插入数据！</p>
<p><code>ps</code>:在RC隔离级别下并不是不会出现死锁，只是出现几率比RR低而已！</p>
<p>*<strong>缘由二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行*</strong>
此时执行语句</p>
<pre><code>update test set color = 'blue' where color = 'red'; 
</code></pre><p>在RC隔离级别下，其先走聚簇索引，进行全部扫描。加锁如下：
<img src="https://img2018.cnblogs.com/blog/725429/201903/725429-20190311135044150-2146259021.png" alt="img">
但在实际中，MySQL做了优化，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁。
实际加锁如下
<img src="https://img2018.cnblogs.com/blog/725429/201903/725429-20190311135057008-2073392330.png" alt="img">
然而，在RR隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上，如下所示
<img src="https://img2018.cnblogs.com/blog/725429/201903/725429-20190311135808965-164228503.jpg" alt="img"></p>
<p>*<strong>缘由三：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！*</strong>
在5.1.15的时候，innodb引入了一个概念叫做“semi-consistent”，减少了更新同一行记录时的冲突，减少锁等待。
所谓半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)！
具体表现如下:
此时有两个Session，Session1和Session2！
Session1执行</p>
<pre><code>update test set color = 'blue' where color = 'red'; 
</code></pre><p>先不Commit事务！
与此同时Ssession2执行</p>
<pre><code>update test set color = 'blue' where color = 'white'; 
</code></pre><p>session 2尝试加锁的时候，发现行上已经存在锁，InnoDB会开启semi-consistent read，返回最新的committed版本(1,red),(2，white),(5,red),(7,white)。MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)!
而在RR隔离级别下，Session2只能等待！</p>
<h3 id="两个疑问">两个疑问</h3>
<p><em>在RC级别下，不可重复读问题需要解决么？</em>
不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？</p>
<p>*<strong>在RC级别下，主从复制用什么binlog格式？*</strong>
<strong>OK,在该隔离级别下，用的binlog为row格式，是基于行的复制！Innodb的创始人也是建议binlog使用该格式！</strong></p>
<h2 id="总结">总结</h2>
<p>本文啰里八嗦了一篇文章只是为了说明一件事，<strong>互联网项目请用：读已提交(Read Commited)这个隔离级别！</strong></p>


  
  <footer>
    <hr>
    
    <div class="post-tags">
    
      <i class="fas fa-tags"></i>
      
        <a href="/tags/mysql">MySQL</a>
        &nbsp;
      
    
    </div>
  </footer>
  

  

<div class="releated-post">
  <h3>Related Posts</h3>
  
  <i class="fas fa-paperclip"></i>
  <a href="/posts/mysql%E4%BA%8B%E5%8A%A1/">【MySQL】事务</a>
  <br>
  
  <i class="fas fa-paperclip"></i>
  <a href="/posts/mysql%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80dcl/">【MySQL】数据管理语言DML</a>
  <br>
  
  <i class="fas fa-paperclip"></i>
  <a href="/posts/mysql%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80dql/">【MySQL】数据查询语言DQL</a>
  <br>
  
  <i class="fas fa-paperclip"></i>
  <a href="/posts/mysql%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E8%AF%AD%E8%A8%80dml/">【MySQL】数据管理语言DML</a>
  <br>
  
  <i class="fas fa-paperclip"></i>
  <a href="/posts/mysql%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">【MySQL】基础架构</a>
  <br>
  
</div>


  <div class="comments">



</div>

</article>



  
  
  
</body>
<div class="foot">
  
  
    &copy; 2019 - 2021 &#183; 
    <a href="/">Home</a> · Theme <a href="https://github.com/RainerChiang/simpleness">Simpleness</a> Powered by <a href="https://gohugo.io/">Hugo</a> &#183;
    <a href="#"><i class="fas fa-chevron-up"></i></a>
  

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'looper', 'auto');
	
	ga('send', 'pageview');
}
</script>

  
</div>

<script src="/js/lazyload.min.js"></script>
<script>
  var lazyImage = new LazyLoad({
    container: document.getElementById('article')
  });
</script>


</html>
